{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>The process of writing code is the synthesis of art and science whereby the compiled code is able to perform tasks which a human could not perform in an entire lifetime.</p> <p>Hello World!</p> <p>I'm a Software Engineer with a bit of Data Engineering experience and I love code. In my spare time I also like to dabble in Strongman and have the occasional whisky. Apparently Software Engineers make blogs or something? So here is mine I guess. </p> <p> Hopefully something here can be of use to you.</p> <p>- Rhexis</p> <ul> <li>LinkedIn</li> <li>Github</li> </ul>"},{"location":"SQL/gaps_and_islands/","title":"Mastering SQL Challenges: Gaps &amp; Islands","text":"<p>In the vast landscape of SQL, mastering its intricacies often involves tackling unique challenges that go beyond simple queries. One such challenge that frequently perplexes SQL practitioners is dealing with  \"gaps and islands\". While the term might sound like something out of a nautical adventure, in the realm of databases, it refers to a common problem of identifying breaks (gaps) and contiguous sequences (islands) within a dataset.</p>"},{"location":"SQL/gaps_and_islands/#what-are-gaps-and-islands","title":"What are gaps and islands?","text":"<p>Before delving into the solutions, let's clarify what we mean by \"gaps\" and \"islands\" in the context of SQL.</p> <p>Gaps: The absence of values within a sequence. For instance, imagine a table of timestamps representing events. If there's a gap between two timestamps, it indicates that there were no events during that period.</p> <p>Islands: Unbroken sequences separated by gaps. In the same table of timestamps, islands would represent uninterrupted periods where events occurred continuously.</p>"},{"location":"SQL/gaps_and_islands/#the-challenge","title":"The Challenge","text":"<p>So, why are gaps and islands a challenge? The complexity arises from the fact that SQL operates on sets of data which aren't inherently ordered. Consequently, identifying sequential patterns isn't straightforward, especially  when dealing with large datasets or data with irregular intervals.</p>"},{"location":"SQL/gaps_and_islands/#possible-strategies","title":"Possible strategies","text":"<p>Fortunately, SQL offers several techniques to address challenges effectively. Here are some common approaches:</p> <ol> <li>Analytic Functions: Functions like <code>ROW_NUMBER()</code>, <code>DENSE_RANK()</code>, <code>LEAD()</code> and <code>LAG()</code> are invaluable    for identifying and categorising sequences of data.</li> <li>Recursive CTEs (Common Table Expressions): While potentially complex and inefficient, they allow for    iterative processing of data, making them useful for tasks involving hierarchical or sequential structures.</li> <li>Self-Joins: Another appreach involves self-joining datasets on themselves, comparing adjacent rows to    detect transitions between gaps and islands. While this method can be resource-intensive for large datasets,     it provides a straightforward way to visualise and understand the data's sequential patterns.</li> </ol>"},{"location":"SQL/gaps_and_islands/#setup","title":"Setup","text":"<p>Lets illustrate some of these techniques with a practical example.</p> <p>Suppose we have a table which is representative of a deck of cards. <pre><code>CREATE TABLE CARDS (\n    SUIT STRING,\n    VALUE INTEGER\n);\nINSERT INTO CARDS\nVALUES\n('HEARTS', 2),\n('HEARTS', 3),\n('HEARTS', 4),\n('HEARTS', 6),\n('HEARTS', 8),\n('HEARTS', 9),\n('HEARTS', 10);\n</code></pre></p>"},{"location":"SQL/gaps_and_islands/#detecting-gaps","title":"Detecting Gaps","text":"<pre><code>SELECT\n    SUIT,\n    VALUE,\n    ROW_NUMBER() OVER (PARTITION BY SUIT ORDER BY VALUE ASC) AS ROW_NUM\nFROM CARDS;\n</code></pre> <p>We know that in a single suit that there is 13 cards, if we check <code>MAX(ROW_NUM)</code>  we can see that it's less than our expected value, therefore this is one indicator of gaps.</p> <p></p>"},{"location":"SQL/gaps_and_islands/#identifying-islands","title":"Identifying Islands","text":"<pre><code>SELECT\n    SUIT,\n    VALUE,\n    ROW_NUMBER() OVER (PARTITION BY SUIT ORDER BY VALUE ASC) AS ROW_NUM,\n    VALUE - ROW_NUMBER() OVER (PARTITION BY SUIT ORDER BY VALUE ASC) AS ISLAND\nFROM CARDS;\n</code></pre> <p>By subtracting the row number from the card value we can see where our islands are.</p> <p></p>"},{"location":"SQL/gaps_and_islands/#managing-duplicates","title":"Managing Duplicates","text":"<p>Unfortunately when it comes to data, we don't always have perfect data sources,  so what happens if duplicates are present? <pre><code>INSERT INTO CARDS\nVALUES\n('HEARTS', 3),\n('HEARTS', 6),\n('HEARTS', 6),\n('HEARTS', 10);\n</code></pre></p> <p>Here we can see that if our data contains duplicates then row number's usefulness breaks down however in SQL however there is more than one ranking function we could use, how about dense rank? <pre><code>SELECT\n    SUIT,\n    VALUE,\n    ROW_NUMBER() OVER (PARTITION BY SUIT ORDER BY VALUE ASC) AS ROW_NUMBER_VALUE,\n    DENSE_RANK() OVER (PARTITION BY SUIT ORDER BY VALUE ASC) AS DENSE_RANK_VALUE,\n    VALUE - ROW_NUMBER() OVER (PARTITION BY SUIT ORDER BY VALUE ASC) AS ROW_NUM_ISLAND,\n    VALUE - DENSE_RANK() OVER (PARTITION BY SUIT ORDER BY VALUE ASC) AS DENSE_RANK_ISLAND\nFROM CARDS;\n</code></pre> As you can see, dense rank is able to work where row number fails.</p> <p></p> <p>Row Number: Returns an incrementing value for all rows sequentially</p> <p>Dense Rank: Returns an incrementing value for all rows sequentially however rows with the same ordering &amp; partitioning will end up with the same value</p>"},{"location":"SQL/gaps_and_islands/#grouping-islands","title":"Grouping Islands","text":"<p>If we group the islands together we start to get a clearer picture of what we have verses what we don't have. <pre><code>WITH ISLANDS AS (\n    SELECT\n        SUIT,\n        VALUE,\n        VALUE - DENSE_RANK() OVER (PARTITION BY SUIT ORDER BY VALUE ASC) AS ISLAND\n    FROM CARDS\n)\nSELECT\n    SUIT,\n    MIN(VALUE) AS ISLAND_START,\n    MAX(VALUE) AS ISLAND_END,\n    MAX(VALUE) - MIN(VALUE) + 1 AS ISLAND_LENGTH,\n    COUNT(SUIT, VALUE) AS CARD_COUNT,\n    COUNT(SUIT, VALUE) - COUNT(DISTINCT SUIT, VALUE) AS DUPLICATE_CARDS\nFROM ISLANDS\nGROUP BY SUIT, ISLAND;\n</code></pre></p> <p></p>"},{"location":"SQL/gaps_and_islands/#identifying-gaps","title":"Identifying gaps","text":"<p>Now that we have identified the islands, what about the gaps? How big are they, how many are there? <pre><code>WITH BOUNDED AS (\n    SELECT SUIT, VALUE\n    FROM CARDS\n    UNION\n    SELECT 'HEARTS' AS SUIT, 0 AS VALUE\n    UNION\n    SELECT 'HEARTS' AS SUIT, 14 AS VALUE\n),\nOFFSETS AS (\n    SELECT\n        SUIT,\n        VALUE,\n        LEAD(VALUE) OVER (PARTITION BY SUIT ORDER BY VALUE ASC) AS NEXT_VALUE\n    FROM BOUNDED\n)\nSELECT\n    SUIT,\n    VALUE + 1 AS GAP_START,\n    NEXT_VALUE - 1 AS GAP_END,\n    GAP_END - GAP_START + 1 AS MISSING_CARD_COUNT\nFROM OFFSETS\nWHERE GAP_END &gt;= GAP_START;\n</code></pre></p> <p>If we set the bounds for our values, 1-13 (inclusive), then we can programmatically work out  where each gap starts &amp; ends.</p> <p></p>"},{"location":"SQL/gaps_and_islands/#conclusion","title":"Conclusion","text":"<p>Mastering SQL's capabilities for handling challenges like gaps and islands opens up a world of possibilities for data analysis and manipulation. By leveraging analytical functions, recursive queries and other advanced SQL features, you can efficiently tackle complex problems and extract valuable insights from your datasets.</p> <p>Whether you're working with time-series data, event logs or any other sequential data structures, understanding  and implementing these techniques will empower you to navigate the seas of SQL with confidence, charting a course toward more insightful and efficient analysis of your data.</p>"}]}